{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutPropertiesLoose = require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\");\nconst _excluded = [\"preserveDynamicRoutes\", \"preserveGroups\", \"shouldEncodeURISegment\"],\n  _excluded2 = [\"#\"];\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDynamicPart = exports.getParamName = exports.getPathWithConventionsCollapsed = exports.appendBaseUrl = exports.appendQueryAndHash = exports.fixCurrentParams = exports.validatePathConfig = void 0;\nconst native_1 = require(\"@react-navigation/native\");\nconst queryString = __importStar(require(\"query-string\"));\nconst matchers_1 = require(\"../matchers\");\nfunction validatePathConfig(_ref) {\n  let options = _objectWithoutPropertiesLoose(_ref, _excluded);\n  (0, native_1.validatePathConfig)(options);\n}\nexports.validatePathConfig = validatePathConfig;\nfunction fixCurrentParams(allParams, route, stringify) {\n  const currentParams = Object.fromEntries(Object.entries(route.params).flatMap(([key, value]) => {\n    if (key === 'screen' || key === 'params') {\n      return [];\n    }\n    return [[key, stringify?.[key] ? stringify[key](value) : Array.isArray(value) ? value.map(String) : String(value)]];\n  }));\n  Object.assign(allParams, currentParams);\n  return currentParams;\n}\nexports.fixCurrentParams = fixCurrentParams;\nfunction appendQueryAndHash(path, _ref2) {\n  let {\n      '#': hash\n    } = _ref2,\n    focusedParams = _objectWithoutPropertiesLoose(_ref2, _excluded2);\n  const query = queryString.stringify(focusedParams, {\n    sort: false\n  });\n  if (query) {\n    path += `?${query}`;\n  }\n  if (hash) {\n    path += `#${hash}`;\n  }\n  return path;\n}\nexports.appendQueryAndHash = appendQueryAndHash;\nfunction appendBaseUrl(path, baseUrl = \"\") {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\nexports.appendBaseUrl = appendBaseUrl;\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  route,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  shouldEncodeURISegment = true,\n  initialRouteName\n}) {\n  const segments = pattern.split('/');\n  return segments.map((p, i) => {\n    const name = (0, exports.getParamName)(p);\n    if (p.startsWith('*')) {\n      if (preserveDynamicRoutes) {\n        if (name === 'not-found') {\n          return '+not-found';\n        }\n        return `[...${name}]`;\n      } else if (params[name]) {\n        if (Array.isArray(params[name])) {\n          return params[name].join('/');\n        }\n        return params[name];\n      } else if (route.name.startsWith('[') && route.name.endsWith(']')) {\n        return '';\n      } else if (p === '*not-found') {\n        return '';\n      } else {\n        return route.name;\n      }\n    }\n    if (p.startsWith(':')) {\n      if (preserveDynamicRoutes) {\n        return `[${name}]`;\n      }\n      const value = params[name];\n      if (value === undefined && p.endsWith('?')) {\n        return;\n      }\n      return (shouldEncodeURISegment ? encodeURISegment(value) : value) ?? 'undefined';\n    }\n    if (!preserveGroups && (0, matchers_1.matchGroupName)(p) != null) {\n      if (segments.length - 1 === i) {\n        if (initialRouteName) {\n          if (segmentMatchesConvention(initialRouteName)) {\n            return '';\n          }\n          return shouldEncodeURISegment ? encodeURISegment(initialRouteName, {\n            preserveBrackets: true\n          }) : initialRouteName;\n        }\n      }\n      return '';\n    }\n    return shouldEncodeURISegment ? encodeURISegment(p, {\n      preserveBrackets: true\n    }) : p;\n  }).map(v => v ?? '').join('/');\n}\nexports.getPathWithConventionsCollapsed = getPathWithConventionsCollapsed;\nconst getParamName = pattern => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\nexports.getParamName = getParamName;\nfunction isDynamicPart(p) {\n  return p.startsWith(':') || p.startsWith('*');\n}\nexports.isDynamicPart = isDynamicPart;\nfunction segmentMatchesConvention(segment) {\n  return segment === 'index' || (0, matchers_1.matchDynamicName)(segment) != null || (0, matchers_1.matchGroupName)(segment) != null || (0, matchers_1.matchDeepDynamicRouteName)(segment) != null;\n}\nfunction encodeURISegment(str, {\n  preserveBrackets = false\n} = {}) {\n  str = String(str).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, char => encodeURIComponent(char));\n  if (preserveBrackets) {\n    str = str.replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n  return str;\n}","map":{"version":3,"names":["native_1","require","queryString","__importStar","matchers_1","validatePathConfig","_ref","options","_objectWithoutPropertiesLoose","_excluded","exports","fixCurrentParams","allParams","route","stringify","currentParams","Object","fromEntries","entries","params","flatMap","key","value","Array","isArray","map","String","assign","appendQueryAndHash","path","_ref2","hash","focusedParams","_excluded2","query","sort","appendBaseUrl","baseUrl","process","env","NODE_ENV","replace","getPathWithConventionsCollapsed","pattern","preserveGroups","preserveDynamicRoutes","shouldEncodeURISegment","initialRouteName","segments","split","p","i","name","getParamName","startsWith","join","endsWith","undefined","encodeURISegment","matchGroupName","length","segmentMatchesConvention","preserveBrackets","v","isDynamicPart","segment","matchDynamicName","matchDeepDynamicRouteName","str","char","encodeURIComponent"],"sources":["/Users/tanishakumari/StudySphere/node_modules/expo-router/src/fork/getPathFromState-forks.ts"],"sourcesContent":["import { validatePathConfig as RNValidatePathConfig, type Route } from '@react-navigation/native';\nimport * as queryString from 'query-string';\n\nimport type { Options, State, StringifyConfig } from './getPathFromState';\nimport { matchDeepDynamicRouteName, matchDynamicName, matchGroupName } from '../matchers';\n\nexport type ExpoOptions = {\n  preserveDynamicRoutes?: boolean;\n  preserveGroups?: boolean;\n  shouldEncodeURISegment?: boolean;\n};\n\nexport type ExpoConfigItem = {\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\nexport function validatePathConfig<ParamList extends object>({\n  preserveDynamicRoutes,\n  preserveGroups,\n  shouldEncodeURISegment,\n  ...options\n}: Options<ParamList>) {\n  RNValidatePathConfig(options);\n}\n\nexport function fixCurrentParams(\n  allParams: Record<string, any>,\n  route: Route<string> & {\n    state?: State;\n  },\n  stringify?: StringifyConfig\n) {\n  // Better handle array params\n  const currentParams = Object.fromEntries(\n    Object.entries(route.params!).flatMap(([key, value]) => {\n      if (key === 'screen' || key === 'params') {\n        return [];\n      }\n\n      return [\n        [\n          key,\n          stringify?.[key]\n            ? stringify[key](value)\n            : Array.isArray(value)\n              ? value.map(String)\n              : String(value),\n        ],\n      ];\n    })\n  );\n\n  // We always assign params, as non pattern routes may still have query params\n  Object.assign(allParams, currentParams);\n\n  return currentParams;\n}\n\nexport function appendQueryAndHash(\n  path: string,\n  { '#': hash, ...focusedParams }: Record<string, any>\n) {\n  const query = queryString.stringify(focusedParams, { sort: false });\n\n  if (query) {\n    path += `?${query}`;\n  }\n\n  if (hash) {\n    path += `#${hash}`;\n  }\n\n  return path;\n}\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n\n  return path;\n}\n\nexport function getPathWithConventionsCollapsed({\n  pattern,\n  route,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  shouldEncodeURISegment = true,\n  initialRouteName,\n}: ExpoOptions & {\n  pattern: string;\n  route: Route<any>;\n  params: Record<string, any>;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n\n  // console.log({ segments, params });\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n\n          return `[...${name}]`;\n        } else if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        } else if (route.name.startsWith('[') && route.name.endsWith(']')) {\n          return '';\n        } else if (p === '*not-found') {\n          return '';\n        } else {\n          return route.name;\n        }\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        const value = params[name];\n        if (value === undefined && p.endsWith('?')) {\n          return;\n        }\n\n        return (shouldEncodeURISegment ? encodeURISegment(value) : value) ?? 'undefined';\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return shouldEncodeURISegment\n              ? encodeURISegment(initialRouteName, { preserveBrackets: true })\n              : initialRouteName;\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return shouldEncodeURISegment ? encodeURISegment(p, { preserveBrackets: true }) : p;\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\nexport const getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nexport function isDynamicPart(p: string) {\n  return p.startsWith(':') || p.startsWith('*');\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' ||\n    matchDynamicName(segment) != null ||\n    matchGroupName(segment) != null ||\n    matchDeepDynamicRouteName(segment) != null\n  );\n}\n\nfunction encodeURISegment(str: string, { preserveBrackets = false } = {}) {\n  // Valid characters according to\n  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)\n  str = String(str).replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]/g, (char) => encodeURIComponent(char));\n\n  if (preserveBrackets) {\n    // Preserve brackets\n    str = str.replace(/%5B/g, '[').replace(/%5D/g, ']');\n  }\n  return str;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}