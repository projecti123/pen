{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseQueryParams = exports.getRouteConfigSorter = exports.appendIsInitial = exports.matchForEmptyPath = exports.stripBaseUrl = exports.spreadParamsAcrossAllStates = exports.handleUrlParams = exports.getParamValue = exports.replacePart = exports.isDynamicPart = exports.configRegExp = exports.assertScreens = exports.createConfig = exports.getUrlWithReactNavigationConcessions = exports.safelyDecodeURIComponent = exports.populateParams = void 0;\nconst escape_string_regexp_1 = __importDefault(require(\"escape-string-regexp\"));\nconst matchers_1 = require(\"../matchers\");\nfunction populateParams(routes, params) {\n  if (!routes || !params || Object.keys(params).length === 0) return;\n  for (const route of routes) {\n    Object.assign(route, {\n      params\n    });\n  }\n  return routes;\n}\nexports.populateParams = populateParams;\nfunction safelyDecodeURIComponent(str) {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    return str;\n  }\n}\nexports.safelyDecodeURIComponent = safelyDecodeURIComponent;\nfunction getUrlWithReactNavigationConcessions(path, baseUrl = \"\") {\n  let parsed;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    return {\n      path,\n      cleanUrl: '',\n      nonstandardPathname: '',\n      url: new URL('https://phony.example')\n    };\n  }\n  const pathname = parsed.pathname;\n  const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);\n  const pathWithoutGroups = (0, matchers_1.stripGroupSegmentsFromPath)(stripBaseUrl(path, baseUrl));\n  return {\n    path,\n    nonstandardPathname: withoutBaseUrl.replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    url: parsed,\n    pathWithoutGroups\n  };\n}\nexports.getUrlWithReactNavigationConcessions = getUrlWithReactNavigationConcessions;\nfunction createConfig(screen, pattern, routeNames, config = {}) {\n  const parts = [];\n  let isDynamic = false;\n  const isIndex = screen === 'index' || screen.endsWith('/index');\n  for (const part of pattern.split('/')) {\n    if (part) {\n      isDynamic ||= part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n      if (!(0, matchers_1.matchGroupName)(part)) {\n        parts.push(part);\n      }\n    }\n  }\n  const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;\n  const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n  if (isIndex) {\n    parts.push('index');\n  }\n  return {\n    type,\n    isIndex,\n    hasChildren,\n    parts,\n    userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),\n    expandedRouteNames: routeNames.flatMap(name => {\n      return name.split('/');\n    })\n  };\n}\nexports.createConfig = createConfig;\nfunction assertScreens(options) {\n  if (!options?.screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n}\nexports.assertScreens = assertScreens;\nfunction configRegExp(config) {\n  return config.pattern ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`) : undefined;\n}\nexports.configRegExp = configRegExp;\nfunction isDynamicPart(p) {\n  return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));\n}\nexports.isDynamicPart = isDynamicPart;\nfunction replacePart(p) {\n  return p.replace(/^[:*]/, '').replace(/\\?$/, '');\n}\nexports.replacePart = replacePart;\nfunction getParamValue(p, value) {\n  if (p.startsWith('*')) {\n    const values = value.split('/').filter(v => v !== '');\n    return values.length === 0 && p.endsWith('?') ? undefined : values;\n  } else {\n    return value;\n  }\n}\nexports.getParamValue = getParamValue;\nfunction formatRegexPattern(it) {\n  it = it.replace(' ', '%20');\n  if (it.startsWith(':')) {\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n  if ((0, matchers_1.matchGroupName)(it) != null) {\n    return `(?:${(0, escape_string_regexp_1.default)(it)}\\\\/)?`;\n  }\n  return (0, escape_string_regexp_1.default)(it) + `\\\\/`;\n}\nfunction handleUrlParams(route, params) {\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params);\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n        }\n      }\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n}\nexports.handleUrlParams = handleUrlParams;\nfunction spreadParamsAcrossAllStates(state, params) {\n  while (state) {\n    const route = state.routes[0];\n    route.params = Object.assign({}, route.params, params);\n  }\n}\nexports.spreadParamsAcrossAllStates = spreadParamsAcrossAllStates;\nfunction stripBaseUrl(path, baseUrl = \"\") {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return path.replace(/^\\/+/g, '/').replace(new RegExp(`^\\\\/?${(0, escape_string_regexp_1.default)(baseUrl)}`, 'g'), '');\n    }\n  }\n  return path;\n}\nexports.stripBaseUrl = stripBaseUrl;\nfunction matchForEmptyPath(configs) {\n  const leafNodes = configs.filter(config => !config.hasChildren).map(value => {\n    return Object.assign({}, value, {\n      path: (0, matchers_1.stripGroupSegmentsFromPath)(value.path)\n    });\n  });\n  const match = leafNodes.find(config => config.path === '' && (!config.regex || config.regex.test(''))) ?? leafNodes.find(config => config.path.startsWith(':') && config.regex.test('')) ?? leafNodes.find(config => config.path.startsWith('*') && config.regex.test('/'));\n  return match;\n}\nexports.matchForEmptyPath = matchForEmptyPath;\nfunction appendIsInitial(initialRoutes) {\n  const resolvedInitialPatterns = initialRoutes.map(route => joinPaths(...route.parentScreens, route.initialRouteName));\n  return function (config) {\n    config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));\n    return config;\n  };\n}\nexports.appendIsInitial = appendIsInitial;\nconst joinPaths = (...paths) => [].concat(...paths.map(p => p.split('/'))).filter(Boolean).join('/');\nfunction getRouteConfigSorter(previousSegments = []) {\n  return function sortConfigs(a, b) {\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n    const similarToPreviousA = previousSegments.filter((value, index) => {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n    const similarToPreviousB = previousSegments.filter((value, index) => {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n    if ((similarToPreviousA.length > 0 || similarToPreviousB.length > 0) && similarToPreviousA.length !== similarToPreviousB.length) {\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n    for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      if (b.parts[i] == null) {\n        return -1;\n      }\n      const aWildCard = a.parts[i].startsWith('*');\n      const bWildCard = b.parts[i].startsWith('*');\n      if (aWildCard && bWildCard) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      if (aWildCard) {\n        return 1;\n      }\n      if (bWildCard) {\n        return -1;\n      }\n      const aSlug = a.parts[i].startsWith(':');\n      const bSlug = b.parts[i].startsWith(':');\n      if (aSlug && bSlug) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      if (aSlug) {\n        return 1;\n      }\n      if (bSlug) {\n        return -1;\n      }\n    }\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n    return b.parts.length - a.parts.length;\n  };\n}\nexports.getRouteConfigSorter = getRouteConfigSorter;\nfunction parseQueryParams(path, route, parseConfig, hash) {\n  const searchParams = new URL(path, 'https://phony.example').searchParams;\n  const params = Object.create(null);\n  if (hash) {\n    params['#'] = hash.slice(1);\n  }\n  for (const name of searchParams.keys()) {\n    if (route.params?.[name]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);\n      }\n    } else {\n      const values = parseConfig?.hasOwnProperty(name) ? searchParams.getAll(name).map(value => parseConfig[name](value)) : searchParams.getAll(name);\n      params[name] = values.length === 1 ? values[0] : values;\n    }\n  }\n  return Object.keys(params).length ? params : undefined;\n}\nexports.parseQueryParams = parseQueryParams;","map":{"version":3,"names":["escape_string_regexp_1","__importDefault","require","matchers_1","populateParams","routes","params","Object","keys","length","route","assign","exports","safelyDecodeURIComponent","str","decodeURIComponent","getUrlWithReactNavigationConcessions","path","baseUrl","parsed","URL","cleanUrl","nonstandardPathname","url","pathname","withoutBaseUrl","stripBaseUrl","pathWithoutGroups","stripGroupSegmentsFromPath","replace","createConfig","screen","pattern","routeNames","config","parts","isDynamic","isIndex","endsWith","part","split","startsWith","includes","matchGroupName","push","hasChildren","screens","type","userReadableName","slice","join","expandedRouteNames","flatMap","name","assertScreens","options","Error","configRegExp","RegExp","map","formatRegexPattern","undefined","isDynamicPart","p","replacePart","getParamValue","value","values","filter","v","it","default","handleUrlParams","create","entries","process","env","NODE_ENV","console","warn","spreadParamsAcrossAllStates","state","matchForEmptyPath","configs","leafNodes","match","find","regex","test","appendIsInitial","initialRoutes","resolvedInitialPatterns","joinPaths","parentScreens","initialRouteName","isInitial","paths","concat","Boolean","getRouteConfigSorter","previousSegments","sortConfigs","a","b","localeCompare","similarToPreviousA","index","similarToPreviousB","i","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","parseQueryParams","parseConfig","hash","searchParams","hasOwnProperty","getAll"],"sources":["/Users/tanishakumari/StudySphere/node_modules/expo-router/src/fork/getStateFromPath-forks.ts"],"sourcesContent":["import { InitialState } from '@react-navigation/native';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport type { InitialRouteConfig, Options, ParsedRoute, RouteConfig } from './getStateFromPath';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\nexport type ExpoOptions = {\n  previousSegments?: string[];\n};\n\nexport type ExpoRouteConfig = {\n  type: 'static' | 'dynamic' | 'layout';\n  userReadableName: string;\n  isIndex: boolean;\n  isInitial?: boolean;\n  hasChildren: boolean;\n  expandedRouteNames: string[];\n  parts: string[];\n};\n\n/**\n * In Expo Router, the params are available at all levels of the routing config\n * @param routes\n * @returns\n */\nexport function populateParams(routes?: ParsedRoute[], params?: Record<string, any>) {\n  if (!routes || !params || Object.keys(params).length === 0) return;\n\n  for (const route of routes) {\n    Object.assign(route, { params });\n  }\n\n  return routes;\n}\n\nexport function safelyDecodeURIComponent(str: string) {\n  try {\n    return decodeURIComponent(str);\n  } catch {\n    return str;\n  }\n}\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      path,\n      cleanUrl: '',\n      nonstandardPathname: '',\n      url: new URL('https://phony.example'),\n    };\n  }\n\n  const pathname = parsed.pathname;\n  const withoutBaseUrl = stripBaseUrl(pathname, baseUrl);\n  const pathWithoutGroups = stripGroupSegmentsFromPath(stripBaseUrl(path, baseUrl));\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    path,\n    nonstandardPathname: withoutBaseUrl.replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    url: parsed,\n    pathWithoutGroups,\n  };\n}\n\nexport function createConfig(\n  screen: string,\n  pattern: string,\n  routeNames: string[],\n  config: Record<string, any> = {}\n): Omit<ExpoRouteConfig, 'isInitial'> {\n  const parts: string[] = [];\n  let isDynamic = false;\n  const isIndex = screen === 'index' || screen.endsWith('/index');\n\n  for (const part of pattern.split('/')) {\n    if (part) {\n      // If any part is dynamic, then the route is dynamic\n      isDynamic ||= part.startsWith(':') || part.startsWith('*') || part.includes('*not-found');\n\n      if (!matchGroupName(part)) {\n        parts.push(part);\n      }\n    }\n  }\n\n  const hasChildren = config.screens ? !!Object.keys(config.screens)?.length : false;\n  const type = hasChildren ? 'layout' : isDynamic ? 'dynamic' : 'static';\n\n  if (isIndex) {\n    parts.push('index');\n  }\n\n  return {\n    type,\n    isIndex,\n    hasChildren,\n    parts,\n    userReadableName: [...routeNames.slice(0, -1), config.path || screen].join('/'),\n    expandedRouteNames: routeNames.flatMap((name) => {\n      return name.split('/');\n    }),\n  };\n}\n\nexport function assertScreens(options?: Options<object>): asserts options is Options<object> {\n  if (!options?.screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n}\n\nexport function configRegExp(config: RouteConfig) {\n  return config.pattern\n    ? new RegExp(`^(${config.pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n}\n\nexport function isDynamicPart(p: string) {\n  return p.length > 1 && (p.startsWith(':') || p.startsWith('*'));\n}\n\nexport function replacePart(p: string) {\n  return p.replace(/^[:*]/, '').replace(/\\?$/, '');\n}\n\nexport function getParamValue(p: string, value: string) {\n  if (p.startsWith('*')) {\n    const values = value.split('/').filter((v) => v !== '');\n    return values.length === 0 && p.endsWith('?') ? undefined : values;\n  } else {\n    return value;\n  }\n}\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nexport function handleUrlParams(route: ParsedRoute, params?: queryString.ParsedQuery) {\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n}\n\nexport function spreadParamsAcrossAllStates(state: InitialState, params?: Record<string, any>) {\n  while (state) {\n    const route = state.routes[0];\n    (route as any).params = Object.assign({}, route.params, params);\n  }\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return path.replace(/^\\/+/g, '/').replace(new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g'), '');\n    }\n  }\n  return path;\n}\n\nexport function matchForEmptyPath(configs: RouteConfig[]) {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  return match;\n}\n\nexport function appendIsInitial(initialRoutes: InitialRouteConfig[]) {\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  return function (config: RouteConfig) {\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    config.isInitial = resolvedInitialPatterns.includes(config.routeNames.join('/'));\n    return config;\n  };\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nexport function getRouteConfigSorter(previousSegments: string[] = []) {\n  return function sortConfigs(a: RouteConfig, b: RouteConfig) {\n    // Sort config so that:\n    // - the most exhaustive ones are always at the beginning\n    // - patterns with wildcard are always at the end\n\n    // If 2 patterns are same, move the one with less route names up\n    // This is an error state, so it's only useful for consistent error messages\n    if (a.pattern === b.pattern) {\n      return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n    }\n\n    /*\n     * If one of the patterns starts with the other, it is earlier in the config sorting.\n     * However, configs are a mix of route configs and layout configs\n     * e.g There will be a config for `/(group)`, but maybe there isn't a `/(group)/index.tsx`\n     *\n     * This is because you can navigate to a directory and its navigator will determine the route\n     * These routes should be later in the config sorting, as their patterns are very open\n     * and will prevent routes from being matched\n     *\n     * Therefore before we compare segment parts, we force these layout configs later in the sorting\n     *\n     * NOTE(marklawlor): Is this a feature we want? I'm unsure if this is a gimmick or a feature.\n     */\n    if (a.pattern.startsWith(b.pattern) && !b.isIndex) {\n      return -1;\n    }\n\n    if (b.pattern.startsWith(a.pattern) && !a.isIndex) {\n      return 1;\n    }\n\n    /*\n     * Static routes should always be higher than dynamic and layout routes.\n     */\n    if (a.type === 'static' && b.type !== 'static') {\n      return -1;\n    } else if (a.type !== 'static' && b.type === 'static') {\n      return 1;\n    }\n\n    /*\n     * If both are static/dynamic or a layout file, then we check group similarity\n     */\n    const similarToPreviousA = previousSegments.filter((value, index) => {\n      return value === a.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    const similarToPreviousB = previousSegments.filter((value, index) => {\n      return value === b.expandedRouteNames[index] && value.startsWith('(') && value.endsWith(')');\n    });\n\n    if (\n      (similarToPreviousA.length > 0 || similarToPreviousB.length > 0) &&\n      similarToPreviousA.length !== similarToPreviousB.length\n    ) {\n      // One matches more than the other, so pick the one that matches more\n      return similarToPreviousB.length - similarToPreviousA.length;\n    }\n\n    /*\n     * If there is not difference in similarity, then each non-group segment is compared against each other\n     */\n    for (let i = 0; i < Math.max(a.parts.length, b.parts.length); i++) {\n      // if b is longer, b get higher priority\n      if (a.parts[i] == null) {\n        return 1;\n      }\n      // if a is longer, a get higher priority\n      if (b.parts[i] == null) {\n        return -1;\n      }\n\n      const aWildCard = a.parts[i].startsWith('*');\n      const bWildCard = b.parts[i].startsWith('*');\n      // if both are wildcard we compare next component\n      if (aWildCard && bWildCard) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aWildCard) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bWildCard) {\n        return -1;\n      }\n\n      const aSlug = a.parts[i].startsWith(':');\n      const bSlug = b.parts[i].startsWith(':');\n      // if both are wildcard we compare next component\n      if (aSlug && bSlug) {\n        const aNotFound = a.parts[i].match(/^[*]not-found$/);\n        const bNotFound = b.parts[i].match(/^[*]not-found$/);\n\n        if (aNotFound && bNotFound) {\n          continue;\n        } else if (aNotFound) {\n          return 1;\n        } else if (bNotFound) {\n          return -1;\n        }\n\n        continue;\n      }\n      // if only a is wild card, b get higher priority\n      if (aSlug) {\n        return 1;\n      }\n      // if only b is wild card, a get higher priority\n      if (bSlug) {\n        return -1;\n      }\n    }\n\n    /*\n     * Both configs are identical in specificity and segments count/type\n     * Try and sort by initial instead.\n     *\n     * TODO: We don't differentiate between the default initialRoute and group specific default routes\n     *\n     * const unstable_settings = {\n     *   \"group\": {\n     *     initialRouteName: \"article\"\n     *  }\n     * }\n     *\n     * \"article\" will be ranked higher because its an initialRoute for a group - even if not your not currently in\n     * that group. The current work around is to ways provide initialRouteName for all groups\n     */\n    if (a.isInitial && !b.isInitial) {\n      return -1;\n    } else if (!a.isInitial && b.isInitial) {\n      return 1;\n    }\n\n    return b.parts.length - a.parts.length;\n  };\n}\n\nexport function parseQueryParams(\n  path: string,\n  route: ParsedRoute,\n  parseConfig?: Record<string, (value: string) => any>,\n  hash?: string\n) {\n  const searchParams = new URL(path, 'https://phony.example').searchParams;\n  const params: Record<string, string | string[]> = Object.create(null);\n\n  if (hash) {\n    params['#'] = hash.slice(1);\n  }\n\n  for (const name of searchParams.keys()) {\n    if (route.params?.[name]) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n        );\n      }\n    } else {\n      const values = parseConfig?.hasOwnProperty(name)\n        ? searchParams.getAll(name).map((value) => parseConfig[name](value))\n        : searchParams.getAll(name);\n\n      // searchParams.getAll returns an array.\n      // if we only have a single value, and its not an array param, we need to extract the value\n      params[name] = values.length === 1 ? values[0] : values;\n    }\n  }\n\n  return Object.keys(params).length ? params : undefined;\n}\n\n/*** ????????? */\n\n// export function mutateRouteParams(\n//   route: ParsedRoute,\n//   params: object,\n//   { allowUrlParamNormalization = false } = {}\n// ) {\n//   route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n//   for (const [name, value] of Object.entries(params)) {\n//     if (route.params?.[name]) {\n//       if (allowUrlParamNormalization) {\n//         route.params[name] = value;\n//       } else {\n//         if (process.env.NODE_ENV !== 'production') {\n//           console.warn(\n//             `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n//           );\n//         }\n//       }\n//     } else {\n//       route.params[name] = value;\n//     }\n//   }\n\n//   if (Object.keys(route.params).length === 0) {\n//     delete route.params;\n//   }\n// }\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}