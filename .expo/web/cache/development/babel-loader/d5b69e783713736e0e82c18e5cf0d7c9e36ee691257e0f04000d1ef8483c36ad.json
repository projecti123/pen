{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateDynamic = exports.extrapolateGroups = exports.getIgnoreList = exports.getRoutes = void 0;\nconst matchers_1 = require(\"./matchers\");\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\nfunction getRoutes(contextModule, options) {\n  const directoryTree = getDirectoryTree(contextModule, options);\n  if (!directoryTree) {\n    return null;\n  }\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n  return rootNode;\n}\nexports.getRoutes = getRoutes;\nfunction getDirectoryTree(contextModule, options) {\n  const importMode = options.importMode || \"sync\";\n  const ignoreList = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/];\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api\\.[tj]sx?$/);\n  }\n  const rootDirectory = {\n    files: new Map(),\n    subdirectories: new Map()\n  };\n  let hasRoutes = false;\n  let isValid = false;\n  for (const filePath of contextModule.keys()) {\n    if (ignoreList.some(regex => regex.test(filePath))) {\n      continue;\n    }\n    isValid = true;\n    const meta = getFileMeta(filePath, options);\n    if (meta.specificity < 0) {\n      continue;\n    }\n    let node = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        let routeModule;\n        if (options.ignoreRequireErrors) {\n          try {\n            routeModule = contextModule(filePath);\n          } catch {\n            routeModule = {};\n          }\n        } else {\n          routeModule = contextModule(filePath);\n        }\n        if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n          if (routeModule instanceof Promise) {\n            throw new Error(`Route \"${filePath}\" cannot be a promise when async routes is disabled.`);\n          }\n          const defaultExport = routeModule?.default;\n          if (defaultExport instanceof Promise) {\n            throw new Error(`The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`);\n          }\n          if (defaultExport instanceof Function && defaultExport.constructor.name === 'AsyncFunction') {\n            throw new Error(`The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`);\n          }\n        }\n        return routeModule;\n      },\n      contextKey: filePath,\n      route: '',\n      dynamic: null,\n      children: []\n    };\n    if (process.env.NODE_ENV === 'development') {\n      if (node.type !== 'api' && importMode === 'sync') {\n        const routeItem = node.loadRoute();\n        const route = routeItem?.default;\n        if (route == null) {\n          console.warn(`Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`);\n          continue;\n        }\n        if (['boolean', 'number', 'string'].includes(typeof route)) {\n          throw new Error(`The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`);\n        }\n      }\n    }\n    for (const route of extrapolateGroups(meta.route)) {\n      const subdirectoryParts = route.split('/').slice(0, -1);\n      let directory = rootDirectory;\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map()\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n        directory = subDirectory;\n      }\n      node = Object.assign({}, node, {\n        route\n      });\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`);\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n        const existing = nodes[0];\n        if (existing) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`);\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`);\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n  if (!isValid) {\n    return null;\n  }\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [options.getSystemRoute({\n      type: 'layout',\n      route: ''\n    })];\n  }\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\nfunction flattenDirectoryTreeToRoutes(directory, options, layout, pathToRemove = '') {\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n    if (options.internal_stripLoadRoute) {\n      delete layout.loadRoute;\n    }\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n    if (options.internal_stripLoadRoute) {\n      delete routeNode.loadRoute;\n    }\n    layout.children.push(routeNode);\n  }\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n  return layout;\n}\nfunction getFileMeta(key, options) {\n  key = key.replace(/^\\.\\//, '');\n  const parts = key.split('/');\n  let route = (0, matchers_1.removeSupportedExtensions)(key);\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] = (0, matchers_1.removeSupportedExtensions)(filename).split('.');\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = filename.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ./${key}. Routes cannot end with '(group)' syntax`);\n  }\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(`Invalid route ./${key}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`);\n  }\n  let specificity = 0;\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      specificity = -1;\n    } else if (!options.platform) {\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      specificity = -1;\n    }\n    if (isApi && specificity !== 0) {\n      throw new Error(`Api routes cannot have platform extensions. Please remove '.${platformExtension}' from './${key}'`);\n    }\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi\n  };\n}\nfunction getIgnoreList(options) {\n  const ignore = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\nexports.getIgnoreList = getIgnoreList;\nfunction extrapolateGroups(key, keys = new Set()) {\n  const match = (0, matchers_1.matchArrayGroupName)(key);\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n  return keys;\n}\nexports.extrapolateGroups = extrapolateGroups;\nfunction generateDynamic(path) {\n  const dynamic = path.split('/').map(part => {\n    if (part === '+not-found') {\n      return {\n        name: '+not-found',\n        deep: true,\n        notFound: true\n      };\n    }\n    const deepDynamicName = (0, matchers_1.matchDeepDynamicRouteName)(part);\n    const dynamicName = deepDynamicName ?? (0, matchers_1.matchDynamicName)(part);\n    if (!dynamicName) return null;\n    return {\n      name: dynamicName,\n      deep: !!deepDynamicName\n    };\n  }).filter(part => !!part);\n  return dynamic.length === 0 ? null : dynamic;\n}\nexports.generateDynamic = generateDynamic;\nfunction appendSitemapRoute(directory, options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [options.getSystemRoute({\n      type: 'route',\n      route: '_sitemap'\n    })]);\n  }\n}\nfunction appendNotFoundRoute(directory, options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [options.getSystemRoute({\n      type: 'route',\n      route: '+not-found'\n    })]);\n  }\n}\nfunction getLayoutNode(node, options) {\n  const groupName = (0, matchers_1.matchLastGroupName)(node.route);\n  const childMatchingGroup = node.children.find(child => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let initialRouteName = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    try {\n      initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n    if (groupName) {\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n  return Object.assign({}, node, {\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [],\n    initialRouteName\n  });\n}\nfunction crawlAndAppendInitialRoutesAndEntryFiles(node, options, entryPoints = []) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n    entryPoints = [...entryPoints, node.contextKey];\n    const groupName = (0, matchers_1.matchGroupName)(node.route);\n    const childMatchingGroup = node.children.find(child => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let initialRouteName = childMatchingGroup?.route;\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        try {\n          initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n        } catch (error) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n        if (groupName) {\n          const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n          initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n        }\n      }\n    }\n    if (initialRouteName) {\n      const initialRoute = node.children.find(child => child.route === initialRouteName);\n      if (!initialRoute) {\n        const validInitialRoutes = node.children.filter(child => !child.generated).map(child => `'${child.route}'`).join(', ');\n        if (groupName) {\n          throw new Error(`Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}' for group '(${groupName})'. Valid options are: ${validInitialRoutes}`);\n        } else {\n          throw new Error(`Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}'. Valid options are: ${validInitialRoutes}`);\n        }\n      }\n      node.initialRouteName = initialRouteName;\n      entryPoints.push(initialRoute.contextKey);\n    }\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\nfunction getMostSpecific(routes) {\n  const route = routes[routes.length - 1];\n  if (!routes[0]) {\n    throw new Error(`The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`);\n  }\n  return routes[routes.length - 1];\n}","map":{"version":3,"names":["matchers_1","require","validPlatforms","Set","getRoutes","contextModule","options","directoryTree","getDirectoryTree","rootNode","flattenDirectoryTreeToRoutes","ignoreEntryPoints","crawlAndAppendInitialRoutesAndEntryFiles","exports","importMode","ignoreList","ignore","push","preserveApiRoutes","rootDirectory","files","Map","subdirectories","hasRoutes","isValid","filePath","keys","some","regex","test","meta","getFileMeta","specificity","node","type","isApi","isLayout","loadRoute","routeModule","ignoreRequireErrors","process","env","NODE_ENV","Promise","Error","defaultExport","default","Function","constructor","name","contextKey","route","dynamic","children","routeItem","console","warn","includes","extrapolateGroups","subdirectoryParts","split","slice","directory","part","subDirectory","get","set","Object","assign","layout","existing","getLayoutNode","fileKey","nodes","getSystemRoute","skipGenerated","sitemap","appendSitemapRoute","notFound","appendNotFoundRoute","pathToRemove","previousLayout","getMostSpecific","internal_stripLoadRoute","newRoute","replace","generateDynamic","routes","values","routeNode","child","key","parts","removeSupportedExtensions","filename","length","filenameWithoutExtensions","platformExtension","match","startsWith","endsWith","renamedRoute","join","hasPlatformExtension","has","usePlatformRoutes","platformRoutes","platform","RegExp","getIgnoreList","matchArrayGroupName","add","groups","groupsSet","size","group","trim","path","map","deep","deepDynamicName","matchDeepDynamicRouteName","dynamicName","matchDynamicName","filter","groupName","matchLastGroupName","childMatchingGroup","find","initialRouteName","loaded","unstable_settings","error","message","groupSpecificInitialRouteName","entryPoints","matchGroupName","initialRoute","validInitialRoutes","generated"],"sources":["/Users/tanishakumari/StudySphere/node_modules/expo-router/src/getRoutesCore.ts"],"sourcesContent":["import type { DynamicConvention, RouteNode } from './Route';\nimport {\n  matchArrayGroupName,\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  matchLastGroupName,\n  removeSupportedExtensions,\n} from './matchers';\nimport type { RequireContext } from './types';\n\nexport type Options = {\n  ignore?: RegExp[];\n  preserveApiRoutes?: boolean;\n  ignoreRequireErrors?: boolean;\n  ignoreEntryPoints?: boolean;\n  /* Used to simplify testing for toEqual() comparison */\n  internal_stripLoadRoute?: boolean;\n  /* Used to simplify by skipping the generated routes */\n  skipGenerated?: boolean;\n  /* Skip the generated not found route  */\n  notFound?: boolean;\n  importMode?: string;\n  platformRoutes?: boolean;\n  sitemap?: boolean;\n  platform?: string;\n\n  /** Get the system route for a location. Useful for shimming React Native imports in SSR environments. */\n  getSystemRoute: (route: Pick<RouteNode, 'route' | 'type'>) => RouteNode;\n};\n\ntype DirectoryNode = {\n  layout?: RouteNode[];\n  files: Map<string, RouteNode[]>;\n  subdirectories: Map<string, DirectoryNode>;\n};\n\nconst validPlatforms = new Set(['android', 'ios', 'native', 'web']);\n\n/**\n * Given a Metro context module, return an array of nested routes.\n *\n * This is a two step process:\n *  1. Convert the RequireContext keys (file paths) into a directory tree.\n *      - This should extrapolate array syntax into multiple routes\n *      - Routes are given a specificity score\n *  2. Flatten the directory tree into routes\n *      - Routes in directories without _layout files are hoisted to the nearest _layout\n *      - The name of the route is relative to the nearest _layout\n *      - If multiple routes have the same name, the most specific route is used\n */\nexport function getRoutes(contextModule: RequireContext, options: Options): RouteNode | null {\n  const directoryTree = getDirectoryTree(contextModule, options);\n\n  // If there are no routes\n  if (!directoryTree) {\n    return null;\n  }\n\n  const rootNode = flattenDirectoryTreeToRoutes(directoryTree, options);\n\n  if (!options.ignoreEntryPoints) {\n    crawlAndAppendInitialRoutesAndEntryFiles(rootNode, options);\n  }\n\n  return rootNode;\n}\n\n/**\n * Converts the RequireContext keys (file paths) into a directory tree.\n */\nfunction getDirectoryTree(contextModule: RequireContext, options: Options) {\n  const importMode = options.importMode || process.env.EXPO_ROUTER_IMPORT_MODE;\n\n  const ignoreList: RegExp[] = [/^\\.\\/\\+(html|native-intent)\\.[tj]sx?$/]; // Ignore the top level ./+html file\n\n  if (options.ignore) {\n    ignoreList.push(...options.ignore);\n  }\n  if (!options.preserveApiRoutes) {\n    ignoreList.push(/\\+api\\.[tj]sx?$/);\n  }\n\n  const rootDirectory: DirectoryNode = {\n    files: new Map(),\n    subdirectories: new Map(),\n  };\n\n  let hasRoutes = false;\n  let isValid = false;\n\n  for (const filePath of contextModule.keys()) {\n    if (ignoreList.some((regex) => regex.test(filePath))) {\n      continue;\n    }\n\n    isValid = true;\n\n    const meta = getFileMeta(filePath, options);\n\n    // This is a file that should be ignored. e.g maybe it has an invalid platform?\n    if (meta.specificity < 0) {\n      continue;\n    }\n\n    let node: RouteNode = {\n      type: meta.isApi ? 'api' : meta.isLayout ? 'layout' : 'route',\n      loadRoute() {\n        let routeModule: any;\n        if (options.ignoreRequireErrors) {\n          try {\n            routeModule = contextModule(filePath);\n          } catch {\n            routeModule = {};\n          }\n        } else {\n          routeModule = contextModule(filePath);\n        }\n\n        if (process.env.NODE_ENV === 'development' && importMode === 'sync') {\n          // In development mode, when async routes are disabled, add some extra error handling to improve the developer experience.\n          // This can be useful when you accidentally use an async function in a route file for the default export.\n          if (routeModule instanceof Promise) {\n            throw new Error(\n              `Route \"${filePath}\" cannot be a promise when async routes is disabled.`\n            );\n          }\n\n          const defaultExport = routeModule?.default;\n          if (defaultExport instanceof Promise) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is a promise. Ensure the React Component does not use async or promises.`\n            );\n          }\n\n          // check if default is an async function without invoking it\n          if (\n            defaultExport instanceof Function &&\n            // This only works on web because Hermes support async functions so we have to transform them out.\n            defaultExport.constructor.name === 'AsyncFunction'\n          ) {\n            throw new Error(\n              `The default export from route \"${filePath}\" is an async function. Ensure the React Component does not use async or promises.`\n            );\n          }\n        }\n\n        return routeModule;\n      },\n      contextKey: filePath,\n      route: '', // This is overwritten during hoisting based upon the _layout\n      dynamic: null,\n      children: [], // While we are building the directory tree, we don't know the node's children just yet. This is added during hoisting\n    };\n\n    if (process.env.NODE_ENV === 'development') {\n      // If the user has set the `EXPO_ROUTER_IMPORT_MODE` to `sync` then we should\n      // filter the missing routes.\n      if (node.type !== 'api' && importMode === 'sync') {\n        const routeItem = node.loadRoute();\n        // Have a warning for nullish ex\n        const route = routeItem?.default;\n        if (route == null) {\n          // Do not throw an error since a user may just be creating a new route.\n          console.warn(\n            `Route \"${filePath}\" is missing the required default export. Ensure a React component is exported as default.`\n          );\n          continue;\n        }\n        if (['boolean', 'number', 'string'].includes(typeof route)) {\n          throw new Error(\n            `The default export from route \"${filePath}\" is an unsupported type: \"${typeof route}\". Only React Components are supported as default exports from route files.`\n          );\n        }\n      }\n    }\n\n    /**\n     * A single filepath may be extrapolated into multiple routes if it contains array syntax.\n     * Another way to thinking about is that a filepath node is present in multiple leaves of the directory tree.\n     */\n    for (const route of extrapolateGroups(meta.route)) {\n      // Traverse the directory tree to its leaf node, creating any missing directories along the way\n      const subdirectoryParts = route.split('/').slice(0, -1);\n\n      // Start at the root directory and traverse the path to the leaf directory\n      let directory = rootDirectory;\n\n      for (const part of subdirectoryParts) {\n        let subDirectory = directory.subdirectories.get(part);\n\n        // Create any missing subdirectories\n        if (!subDirectory) {\n          subDirectory = {\n            files: new Map(),\n            subdirectories: new Map(),\n          };\n          directory.subdirectories.set(part, subDirectory);\n        }\n\n        directory = subDirectory;\n      }\n\n      // Clone the node for this route\n      node = { ...node, route };\n\n      if (meta.isLayout) {\n        directory.layout ??= [];\n        const existing = directory.layout[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The layouts \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          node = getLayoutNode(node, options);\n          directory.layout[meta.specificity] = node;\n        }\n      } else if (meta.isApi) {\n        const fileKey = `${route}+api`;\n        let nodes = directory.files.get(fileKey);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(fileKey, nodes);\n        }\n\n        // API Routes have no specificity, they are always the first node\n        const existing = nodes[0];\n\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The API route file \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          nodes[0] = node;\n        }\n      } else {\n        let nodes = directory.files.get(route);\n\n        if (!nodes) {\n          nodes = [];\n          directory.files.set(route, nodes);\n        }\n\n        /**\n         * If there is an existing node with the same specificity, then we have a conflict.\n         * NOTE(Platform Routes):\n         *    We cannot check for specificity conflicts here, as we haven't processed all the context keys yet!\n         *    This will be checked during hoisting, as well as enforcing that all routes have a non-platform route.\n         */\n        const existing = nodes[meta.specificity];\n        if (existing) {\n          // In production, use the first route found\n          if (process.env.NODE_ENV !== 'production') {\n            throw new Error(\n              `The route files \"${filePath}\" and \"${existing.contextKey}\" conflict on the route \"/${route}\". Please remove or rename one of these files.`\n            );\n          }\n        } else {\n          hasRoutes ||= true;\n          nodes[meta.specificity] = node;\n        }\n      }\n    }\n  }\n\n  // If there are no routes/layouts then we should display the tutorial.\n  if (!isValid) {\n    return null;\n  }\n\n  /**\n   * If there are no top-level _layout, add a default _layout\n   * While this is a generated route, it will still be generated even if skipGenerated is true.\n   */\n  if (!rootDirectory.layout) {\n    rootDirectory.layout = [\n      options.getSystemRoute({\n        type: 'layout',\n        route: '',\n      }),\n    ];\n  }\n\n  // Only include the sitemap if there are routes.\n  if (!options.skipGenerated) {\n    if (hasRoutes && options.sitemap !== false) {\n      appendSitemapRoute(rootDirectory, options);\n    }\n    if (options.notFound !== false) {\n      appendNotFoundRoute(rootDirectory, options);\n    }\n  }\n  return rootDirectory;\n}\n\n/**\n * Flatten the directory tree into routes, hoisting routes to the nearest _layout.\n */\nfunction flattenDirectoryTreeToRoutes(\n  directory: DirectoryNode,\n  options: Options,\n  /* The nearest _layout file in the directory tree */\n  layout?: RouteNode,\n  /* Route names are relative to their layout */\n  pathToRemove = ''\n) {\n  /**\n   * This directory has a _layout file so it becomes the new target for hoisting routes.\n   */\n  if (directory.layout) {\n    const previousLayout = layout;\n    layout = getMostSpecific(directory.layout);\n\n    // Add the new layout as a child of its parent\n    if (previousLayout) {\n      previousLayout.children.push(layout);\n    }\n\n    if (options.internal_stripLoadRoute) {\n      delete (layout as any).loadRoute;\n    }\n\n    // `route` is the absolute pathname. We need to make this relative to the last _layout\n    const newRoute = layout.route.replace(pathToRemove, '');\n    pathToRemove = layout.route ? `${layout.route}/` : '';\n\n    // Now update this layout with the new relative route and dynamic conventions\n    layout.route = newRoute;\n    layout.dynamic = generateDynamic(layout.contextKey.slice(0));\n  }\n\n  // This should never occur as there will always be a root layout, but it makes the type system happy\n  if (!layout) throw new Error('Expo Router Internal Error: No nearest layout');\n\n  for (const routes of directory.files.values()) {\n    const routeNode = getMostSpecific(routes);\n\n    // `route` is the absolute pathname. We need to make this relative to the nearest layout\n    routeNode.route = routeNode.route.replace(pathToRemove, '');\n    routeNode.dynamic = generateDynamic(routeNode.route);\n\n    if (options.internal_stripLoadRoute) {\n      delete (routeNode as any).loadRoute;\n    }\n\n    layout.children.push(routeNode);\n  }\n\n  // Recursively flatten the subdirectories\n  for (const child of directory.subdirectories.values()) {\n    flattenDirectoryTreeToRoutes(child, options, layout, pathToRemove);\n  }\n\n  return layout;\n}\n\nfunction getFileMeta(key: string, options: Options) {\n  // Remove the leading `./`\n  key = key.replace(/^\\.\\//, '');\n\n  const parts = key.split('/');\n  let route = removeSupportedExtensions(key);\n  const filename = parts[parts.length - 1];\n  const [filenameWithoutExtensions, platformExtension] =\n    removeSupportedExtensions(filename).split('.');\n  const isLayout = filenameWithoutExtensions === '_layout';\n  const isApi = filename.match(/\\+api\\.(\\w+\\.)?[jt]sx?$/);\n\n  if (filenameWithoutExtensions.startsWith('(') && filenameWithoutExtensions.endsWith(')')) {\n    throw new Error(`Invalid route ./${key}. Routes cannot end with '(group)' syntax`);\n  }\n\n  // Nested routes cannot start with the '+' character, except for the '+not-found' route\n  if (!isApi && filename.startsWith('+') && filenameWithoutExtensions !== '+not-found') {\n    const renamedRoute = [...parts.slice(0, -1), filename.slice(1)].join('/');\n    throw new Error(\n      `Invalid route ./${key}. Route nodes cannot start with the '+' character. \"Please rename to ${renamedRoute}\"`\n    );\n  }\n  let specificity = 0;\n\n  const hasPlatformExtension = validPlatforms.has(platformExtension);\n  const usePlatformRoutes = options.platformRoutes ?? true;\n\n  if (hasPlatformExtension) {\n    if (!usePlatformRoutes) {\n      // If the user has disabled platform routes, then we should ignore this file\n      specificity = -1;\n    } else if (!options.platform) {\n      // If we don't have a platform, then we should ignore this file\n      // This used by typed routes, sitemap, etc\n      specificity = -1;\n    } else if (platformExtension === options.platform) {\n      // If the platform extension is the same as the options.platform, then it is the most specific\n      specificity = 2;\n    } else if (platformExtension === 'native' && options.platform !== 'web') {\n      // `native` is allow but isn't as specific as the platform\n      specificity = 1;\n    } else if (platformExtension !== options.platform) {\n      // Somehow we have a platform extension that doesn't match the options.platform and it isn't native\n      // This is an invalid file and we will ignore it\n      specificity = -1;\n    }\n\n    if (isApi && specificity !== 0) {\n      throw new Error(\n        `Api routes cannot have platform extensions. Please remove '.${platformExtension}' from './${key}'`\n      );\n    }\n\n    route = route.replace(new RegExp(`.${platformExtension}$`), '');\n  }\n\n  return {\n    route,\n    specificity,\n    isLayout,\n    isApi,\n  };\n}\n\nexport function getIgnoreList(options?: Options) {\n  const ignore: RegExp[] = [/^\\.\\/\\+html\\.[tj]sx?$/, ...(options?.ignore ?? [])];\n  if (options?.preserveApiRoutes !== true) {\n    ignore.push(/\\+api\\.[tj]sx?$/);\n  }\n  return ignore;\n}\n\n/**\n * Generates a set of strings which have the router array syntax extrapolated.\n *\n * /(a,b)/(c,d)/e.tsx => new Set(['a/c/e.tsx', 'a/d/e.tsx', 'b/c/e.tsx', 'b/d/e.tsx'])\n */\nexport function extrapolateGroups(key: string, keys: Set<string> = new Set()): Set<string> {\n  const match = matchArrayGroupName(key);\n\n  if (!match) {\n    keys.add(key);\n    return keys;\n  }\n  const groups = match.split(',');\n  const groupsSet = new Set(groups);\n\n  if (groupsSet.size !== groups.length) {\n    throw new Error(`Array syntax cannot contain duplicate group name \"${groups}\" in \"${key}\".`);\n  }\n\n  if (groups.length === 1) {\n    keys.add(key);\n    return keys;\n  }\n\n  for (const group of groups) {\n    extrapolateGroups(key.replace(match, group.trim()), keys);\n  }\n\n  return keys;\n}\n\nexport function generateDynamic(path: string): DynamicConvention[] | null {\n  const dynamic = path\n    .split('/')\n    .map((part): DynamicConvention | null => {\n      if (part === '+not-found') {\n        return {\n          name: '+not-found',\n          deep: true,\n          notFound: true,\n        };\n      }\n\n      const deepDynamicName = matchDeepDynamicRouteName(part);\n      const dynamicName = deepDynamicName ?? matchDynamicName(part);\n\n      if (!dynamicName) return null;\n      return { name: dynamicName, deep: !!deepDynamicName };\n    })\n    .filter((part): part is DynamicConvention => !!part);\n\n  return dynamic.length === 0 ? null : dynamic;\n}\n\nfunction appendSitemapRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('_sitemap') && options.getSystemRoute) {\n    directory.files.set('_sitemap', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '_sitemap',\n      }),\n    ]);\n  }\n}\n\nfunction appendNotFoundRoute(directory: DirectoryNode, options: Options) {\n  if (!directory.files.has('+not-found') && options.getSystemRoute) {\n    directory.files.set('+not-found', [\n      options.getSystemRoute({\n        type: 'route',\n        route: '+not-found',\n      }),\n    ]);\n  }\n}\n\nfunction getLayoutNode(node: RouteNode, options: Options) {\n  /**\n   * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n   * Each of these layouts will have a different initialRouteName based upon the first group name.\n   */\n  // We may strip loadRoute during testing\n  const groupName = matchLastGroupName(node.route);\n  const childMatchingGroup = node.children.find((child) => {\n    return child.route.replace(/\\/index$/, '') === groupName;\n  });\n  let initialRouteName = childMatchingGroup?.route;\n  const loaded = node.loadRoute();\n  if (loaded?.unstable_settings) {\n    try {\n      // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n      initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n    } catch (error: any) {\n      if (error instanceof Error) {\n        if (!error.message.match(/You cannot dot into a client module/)) {\n          throw error;\n        }\n      }\n    }\n\n    if (groupName) {\n      // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n      const groupSpecificInitialRouteName = loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n      initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n    }\n  }\n\n  return {\n    ...node,\n    route: node.route.replace(/\\/?_layout$/, ''),\n    children: [], // Each layout should have its own children\n    initialRouteName,\n  };\n}\n\nfunction crawlAndAppendInitialRoutesAndEntryFiles(\n  node: RouteNode,\n  options: Options,\n  entryPoints: string[] = []\n) {\n  if (node.type === 'route') {\n    node.entryPoints = [...new Set([...entryPoints, node.contextKey])];\n  } else if (node.type === 'layout') {\n    if (!node.children) {\n      throw new Error(`Layout \"${node.contextKey}\" does not contain any child routes`);\n    }\n\n    // Every node below this layout will have it as an entryPoint\n    entryPoints = [...entryPoints, node.contextKey];\n\n    /**\n     * Calculate the initialRouteNode\n     *\n     * A file called `(a,b)/(c)/_layout.tsx` will generate two _layout routes: `(a)/(c)/_layout` and `(b)/(c)/_layout`.\n     * Each of these layouts will have a different initialRouteName based upon the first group.\n     */\n    const groupName = matchGroupName(node.route);\n    const childMatchingGroup = node.children.find((child) => {\n      return child.route.replace(/\\/index$/, '') === groupName;\n    });\n    let initialRouteName = childMatchingGroup?.route;\n    // We may strip loadRoute during testing\n    if (!options.internal_stripLoadRoute) {\n      const loaded = node.loadRoute();\n      if (loaded?.unstable_settings) {\n        try {\n          // Allow unstable_settings={ initialRouteName: '...' } to override the default initial route name.\n          initialRouteName = loaded.unstable_settings.initialRouteName ?? initialRouteName;\n        } catch (error: any) {\n          if (error instanceof Error) {\n            if (!error.message.match(/You cannot dot into a client module/)) {\n              throw error;\n            }\n          }\n        }\n\n        if (groupName) {\n          // Allow unstable_settings={ 'custom': { initialRouteName: '...' } } to override the less specific initial route name.\n          const groupSpecificInitialRouteName =\n            loaded.unstable_settings?.[groupName]?.initialRouteName;\n\n          initialRouteName = groupSpecificInitialRouteName ?? initialRouteName;\n        }\n      }\n    }\n\n    if (initialRouteName) {\n      const initialRoute = node.children.find((child) => child.route === initialRouteName);\n      if (!initialRoute) {\n        const validInitialRoutes = node.children\n          .filter((child) => !child.generated)\n          .map((child) => `'${child.route}'`)\n          .join(', ');\n\n        if (groupName) {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}' for group '(${groupName})'. Valid options are: ${validInitialRoutes}`\n          );\n        } else {\n          throw new Error(\n            `Layout ${node.contextKey} has invalid initialRouteName '${initialRouteName}'. Valid options are: ${validInitialRoutes}`\n          );\n        }\n      }\n\n      // Navigators can add initialsRoutes into the history, so they need to be to be included in the entryPoints\n      node.initialRouteName = initialRouteName;\n      entryPoints.push(initialRoute.contextKey);\n    }\n\n    for (const child of node.children) {\n      crawlAndAppendInitialRoutesAndEntryFiles(child, options, entryPoints);\n    }\n  }\n}\n\nfunction getMostSpecific(routes: RouteNode[]) {\n  const route = routes[routes.length - 1];\n\n  if (!routes[0]) {\n    throw new Error(\n      `The file ${route.contextKey} does not have a fallback sibling file without a platform extension.`\n    );\n  }\n\n  // This works even tho routes is holey array (e.g it might have index 0 and 2 but not 1)\n  // `.length` includes the holes in its count\n  return routes[routes.length - 1];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}