{"ast":null,"code":"\"use strict\";\n\nimport { getHeaderTitle, Header, SafeAreaProviderCompat, Screen } from '@react-navigation/elements';\nimport { StackActions, useLocale } from '@react-navigation/native';\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\nimport { FadeTransition, ShiftTransition } from \"../TransitionConfigs/TransitionPresets.js\";\nimport { BottomTabBarHeightCallbackContext } from \"../utils/BottomTabBarHeightCallbackContext.js\";\nimport { BottomTabBarHeightContext } from \"../utils/BottomTabBarHeightContext.js\";\nimport { useAnimatedHashMap } from \"../utils/useAnimatedHashMap.js\";\nimport { BottomTabBar, getTabBarHeight } from \"./BottomTabBar.js\";\nimport { MaybeScreen, MaybeScreenContainer } from \"./ScreenFallback.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst EPSILON = 1e-5;\nconst STATE_INACTIVE = 0;\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nconst STATE_ON_TOP = 2;\nconst NAMED_TRANSITIONS_PRESETS = {\n  fade: FadeTransition,\n  shift: ShiftTransition,\n  none: {\n    sceneStyleInterpolator: undefined,\n    transitionSpec: {\n      animation: 'timing',\n      config: {\n        duration: 0\n      }\n    }\n  }\n};\nconst useNativeDriver = Platform.OS !== 'web';\nconst hasAnimation = options => {\n  const {\n    animation,\n    transitionSpec\n  } = options;\n  if (animation) {\n    return animation !== 'none';\n  }\n  return Boolean(transitionSpec);\n};\nconst renderTabBarDefault = props => _jsx(BottomTabBar, Object.assign({}, props));\nexport function BottomTabView(props) {\n  const {\n    tabBar = renderTabBarDefault,\n    state,\n    navigation,\n    descriptors,\n    safeAreaInsets,\n    detachInactiveScreens = Platform.OS === 'web' || Platform.OS === 'android' || Platform.OS === 'ios'\n  } = props;\n  const focusedRouteKey = state.routes[state.index].key;\n  const {\n    direction\n  } = useLocale();\n  const [loaded, setLoaded] = React.useState([focusedRouteKey]);\n  if (!loaded.includes(focusedRouteKey)) {\n    setLoaded([...loaded, focusedRouteKey]);\n  }\n  const previousRouteKeyRef = React.useRef(focusedRouteKey);\n  const tabAnims = useAnimatedHashMap(state);\n  React.useEffect(() => {\n    const previousRouteKey = previousRouteKeyRef.current;\n    let popToTopAction;\n    if (previousRouteKey !== focusedRouteKey && descriptors[previousRouteKey]?.options.popToTopOnBlur) {\n      const prevRoute = state.routes.find(route => route.key === previousRouteKey);\n      if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {\n        popToTopAction = Object.assign({}, StackActions.popToTop(), {\n          target: prevRoute.state.key\n        });\n      }\n    }\n    const animateToIndex = () => {\n      if (previousRouteKey !== focusedRouteKey) {\n        navigation.emit({\n          type: 'transitionStart',\n          target: focusedRouteKey\n        });\n      }\n      Animated.parallel(state.routes.map((route, index) => {\n        const {\n          options\n        } = descriptors[route.key];\n        const {\n          animation = 'none',\n          transitionSpec = NAMED_TRANSITIONS_PRESETS[animation].transitionSpec\n        } = options;\n        let spec = transitionSpec;\n        if (route.key !== previousRouteKey && route.key !== focusedRouteKey) {\n          spec = NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n        }\n        spec = spec ?? NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n        const toValue = index === state.index ? 0 : index >= state.index ? 1 : -1;\n        return Animated[spec.animation](tabAnims[route.key], Object.assign({}, spec.config, {\n          toValue,\n          useNativeDriver\n        }));\n      }).filter(Boolean)).start(({\n        finished\n      }) => {\n        if (finished && popToTopAction) {\n          navigation.dispatch(popToTopAction);\n        }\n        if (previousRouteKey !== focusedRouteKey) {\n          navigation.emit({\n            type: 'transitionEnd',\n            target: focusedRouteKey\n          });\n        }\n      });\n    };\n    animateToIndex();\n    previousRouteKeyRef.current = focusedRouteKey;\n  }, [descriptors, focusedRouteKey, navigation, state.index, state.routes, tabAnims]);\n  const dimensions = SafeAreaProviderCompat.initialMetrics.frame;\n  const [tabBarHeight, setTabBarHeight] = React.useState(() => getTabBarHeight({\n    state,\n    descriptors,\n    dimensions,\n    insets: Object.assign({}, SafeAreaProviderCompat.initialMetrics.insets, props.safeAreaInsets),\n    style: descriptors[state.routes[state.index].key].options.tabBarStyle\n  }));\n  const renderTabBar = () => {\n    return _jsx(SafeAreaInsetsContext.Consumer, {\n      children: insets => tabBar({\n        state: state,\n        descriptors: descriptors,\n        navigation: navigation,\n        insets: {\n          top: safeAreaInsets?.top ?? insets?.top ?? 0,\n          right: safeAreaInsets?.right ?? insets?.right ?? 0,\n          bottom: safeAreaInsets?.bottom ?? insets?.bottom ?? 0,\n          left: safeAreaInsets?.left ?? insets?.left ?? 0\n        }\n      })\n    });\n  };\n  const {\n    routes\n  } = state;\n  const hasTwoStates = !routes.some(route => hasAnimation(descriptors[route.key].options));\n  const {\n    tabBarPosition = 'bottom'\n  } = descriptors[focusedRouteKey].options;\n  return _jsxs(SafeAreaProviderCompat, {\n    style: {\n      flexDirection: tabBarPosition === 'left' || tabBarPosition === 'right' ? tabBarPosition === 'left' && direction === 'ltr' || tabBarPosition === 'right' && direction === 'rtl' ? 'row-reverse' : 'row' : 'column'\n    },\n    children: [tabBarPosition === 'top' ? _jsx(BottomTabBarHeightCallbackContext.Provider, {\n      value: setTabBarHeight,\n      children: renderTabBar()\n    }) : null, _jsx(MaybeScreenContainer, {\n      enabled: detachInactiveScreens,\n      hasTwoStates: hasTwoStates,\n      style: styles.screens,\n      children: routes.map((route, index) => {\n        const descriptor = descriptors[route.key];\n        const {\n          lazy = true,\n          animation = 'none',\n          sceneStyleInterpolator = NAMED_TRANSITIONS_PRESETS[animation].sceneStyleInterpolator\n        } = descriptor.options;\n        const isFocused = state.index === index;\n        const isPreloaded = state.preloadedRouteKeys.includes(route.key);\n        if (lazy && !loaded.includes(route.key) && !isFocused && !isPreloaded) {\n          return null;\n        }\n        const {\n          freezeOnBlur,\n          header = ({\n            layout,\n            options\n          }) => _jsx(Header, Object.assign({}, options, {\n            layout: layout,\n            title: getHeaderTitle(options, route.name)\n          })),\n          headerShown,\n          headerStatusBarHeight,\n          headerTransparent,\n          sceneStyle: customSceneStyle\n        } = descriptor.options;\n        const {\n          sceneStyle\n        } = sceneStyleInterpolator?.({\n          current: {\n            progress: tabAnims[route.key]\n          }\n        }) ?? {};\n        const animationEnabled = hasAnimation(descriptor.options);\n        const activityState = isFocused ? STATE_ON_TOP : animationEnabled ? tabAnims[route.key].interpolate({\n          inputRange: [0, 1 - EPSILON, 1],\n          outputRange: [STATE_TRANSITIONING_OR_BELOW_TOP, STATE_TRANSITIONING_OR_BELOW_TOP, STATE_INACTIVE],\n          extrapolate: 'extend'\n        }) : STATE_INACTIVE;\n        return _jsx(MaybeScreen, {\n          style: [StyleSheet.absoluteFill, {\n            zIndex: isFocused ? 0 : -1\n          }],\n          active: activityState,\n          enabled: detachInactiveScreens,\n          freezeOnBlur: freezeOnBlur,\n          shouldFreeze: activityState === STATE_INACTIVE && !isPreloaded,\n          children: _jsx(BottomTabBarHeightContext.Provider, {\n            value: tabBarPosition === 'bottom' ? tabBarHeight : 0,\n            children: _jsx(Screen, {\n              focused: isFocused,\n              route: descriptor.route,\n              navigation: descriptor.navigation,\n              headerShown: headerShown,\n              headerStatusBarHeight: headerStatusBarHeight,\n              headerTransparent: headerTransparent,\n              header: header({\n                layout: dimensions,\n                route: descriptor.route,\n                navigation: descriptor.navigation,\n                options: descriptor.options\n              }),\n              style: [customSceneStyle, animationEnabled && sceneStyle],\n              children: descriptor.render()\n            })\n          })\n        }, route.key);\n      })\n    }), tabBarPosition !== 'top' ? _jsx(BottomTabBarHeightCallbackContext.Provider, {\n      value: setTabBarHeight,\n      children: renderTabBar()\n    }) : null]\n  });\n}\nconst styles = StyleSheet.create({\n  screens: {\n    flex: 1,\n    overflow: 'hidden'\n  }\n});","map":{"version":3,"names":["getHeaderTitle","Header","SafeAreaProviderCompat","Screen","StackActions","useLocale","React","Animated","Platform","StyleSheet","SafeAreaInsetsContext","FadeTransition","ShiftTransition","BottomTabBarHeightCallbackContext","BottomTabBarHeightContext","useAnimatedHashMap","BottomTabBar","getTabBarHeight","MaybeScreen","MaybeScreenContainer","jsx","_jsx","jsxs","_jsxs","EPSILON","STATE_INACTIVE","STATE_TRANSITIONING_OR_BELOW_TOP","STATE_ON_TOP","NAMED_TRANSITIONS_PRESETS","fade","shift","none","sceneStyleInterpolator","undefined","transitionSpec","animation","config","duration","useNativeDriver","OS","hasAnimation","options","Boolean","renderTabBarDefault","props","Object","assign","BottomTabView","tabBar","state","navigation","descriptors","safeAreaInsets","detachInactiveScreens","focusedRouteKey","routes","index","key","direction","loaded","setLoaded","useState","includes","previousRouteKeyRef","useRef","tabAnims","useEffect","previousRouteKey","current","popToTopAction","popToTopOnBlur","prevRoute","find","route","type","popToTop","target","animateToIndex","emit","parallel","map","spec","toValue","filter","start","finished","dispatch","dimensions","initialMetrics","frame","tabBarHeight","setTabBarHeight","insets","style","tabBarStyle","renderTabBar","Consumer","children","top","right","bottom","left","hasTwoStates","some","tabBarPosition","flexDirection","Provider","value","enabled","styles","screens","descriptor","lazy","isFocused","isPreloaded","preloadedRouteKeys","freezeOnBlur","header","layout","title","name","headerShown","headerStatusBarHeight","headerTransparent","sceneStyle","customSceneStyle","progress","animationEnabled","activityState","interpolate","inputRange","outputRange","extrapolate","absoluteFill","zIndex","active","shouldFreeze","focused","render","create","flex","overflow"],"sources":["/Users/tanishakumari/StudySphere/node_modules/@react-navigation/bottom-tabs/src/views/BottomTabView.tsx"],"sourcesContent":["import {\n  getHeaderTitle,\n  Header,\n  SafeAreaProviderCompat,\n  Screen,\n} from '@react-navigation/elements';\nimport {\n  type NavigationAction,\n  type ParamListBase,\n  StackActions,\n  type TabNavigationState,\n  useLocale,\n} from '@react-navigation/native';\nimport * as React from 'react';\nimport { Animated, Platform, StyleSheet } from 'react-native';\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\n\nimport {\n  FadeTransition,\n  ShiftTransition,\n} from '../TransitionConfigs/TransitionPresets';\nimport type {\n  BottomTabBarProps,\n  BottomTabDescriptorMap,\n  BottomTabHeaderProps,\n  BottomTabNavigationConfig,\n  BottomTabNavigationHelpers,\n  BottomTabNavigationOptions,\n  BottomTabNavigationProp,\n} from '../types';\nimport { BottomTabBarHeightCallbackContext } from '../utils/BottomTabBarHeightCallbackContext';\nimport { BottomTabBarHeightContext } from '../utils/BottomTabBarHeightContext';\nimport { useAnimatedHashMap } from '../utils/useAnimatedHashMap';\nimport { BottomTabBar, getTabBarHeight } from './BottomTabBar';\nimport { MaybeScreen, MaybeScreenContainer } from './ScreenFallback';\n\ntype Props = BottomTabNavigationConfig & {\n  state: TabNavigationState<ParamListBase>;\n  navigation: BottomTabNavigationHelpers;\n  descriptors: BottomTabDescriptorMap;\n};\n\nconst EPSILON = 1e-5;\nconst STATE_INACTIVE = 0;\nconst STATE_TRANSITIONING_OR_BELOW_TOP = 1;\nconst STATE_ON_TOP = 2;\n\nconst NAMED_TRANSITIONS_PRESETS = {\n  fade: FadeTransition,\n  shift: ShiftTransition,\n  none: {\n    sceneStyleInterpolator: undefined,\n    transitionSpec: {\n      animation: 'timing',\n      config: { duration: 0 },\n    },\n  },\n} as const;\n\nconst useNativeDriver = Platform.OS !== 'web';\n\nconst hasAnimation = (options: BottomTabNavigationOptions) => {\n  const { animation, transitionSpec } = options;\n\n  if (animation) {\n    return animation !== 'none';\n  }\n\n  return Boolean(transitionSpec);\n};\n\nconst renderTabBarDefault = (props: BottomTabBarProps) => (\n  <BottomTabBar {...props} />\n);\n\nexport function BottomTabView(props: Props) {\n  const {\n    tabBar = renderTabBarDefault,\n    state,\n    navigation,\n    descriptors,\n    safeAreaInsets,\n    detachInactiveScreens = Platform.OS === 'web' ||\n      Platform.OS === 'android' ||\n      Platform.OS === 'ios',\n  } = props;\n\n  const focusedRouteKey = state.routes[state.index].key;\n\n  const { direction } = useLocale();\n\n  /**\n   * List of loaded tabs, tabs will be loaded when navigated to.\n   */\n  const [loaded, setLoaded] = React.useState([focusedRouteKey]);\n\n  if (!loaded.includes(focusedRouteKey)) {\n    // Set the current tab to be loaded if it was not loaded before\n    setLoaded([...loaded, focusedRouteKey]);\n  }\n\n  const previousRouteKeyRef = React.useRef(focusedRouteKey);\n  const tabAnims = useAnimatedHashMap(state);\n\n  React.useEffect(() => {\n    const previousRouteKey = previousRouteKeyRef.current;\n\n    let popToTopAction: NavigationAction | undefined;\n\n    if (\n      previousRouteKey !== focusedRouteKey &&\n      descriptors[previousRouteKey]?.options.popToTopOnBlur\n    ) {\n      const prevRoute = state.routes.find(\n        (route) => route.key === previousRouteKey\n      );\n\n      if (prevRoute?.state?.type === 'stack' && prevRoute.state.key) {\n        popToTopAction = {\n          ...StackActions.popToTop(),\n          target: prevRoute.state.key,\n        };\n      }\n    }\n\n    const animateToIndex = () => {\n      if (previousRouteKey !== focusedRouteKey) {\n        navigation.emit({\n          type: 'transitionStart',\n          target: focusedRouteKey,\n        });\n      }\n\n      Animated.parallel(\n        state.routes\n          .map((route, index) => {\n            const { options } = descriptors[route.key];\n            const {\n              animation = 'none',\n              transitionSpec = NAMED_TRANSITIONS_PRESETS[animation]\n                .transitionSpec,\n            } = options;\n\n            let spec = transitionSpec;\n\n            if (\n              route.key !== previousRouteKey &&\n              route.key !== focusedRouteKey\n            ) {\n              // Don't animate if the screen is not previous one or new one\n              // This will avoid flicker for screens not involved in the transition\n              spec = NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n            }\n\n            spec = spec ?? NAMED_TRANSITIONS_PRESETS.none.transitionSpec;\n\n            const toValue =\n              index === state.index ? 0 : index >= state.index ? 1 : -1;\n\n            return Animated[spec.animation](tabAnims[route.key], {\n              ...spec.config,\n              toValue,\n              useNativeDriver,\n            });\n          })\n          .filter(Boolean) as Animated.CompositeAnimation[]\n      ).start(({ finished }) => {\n        if (finished && popToTopAction) {\n          navigation.dispatch(popToTopAction);\n        }\n\n        if (previousRouteKey !== focusedRouteKey) {\n          navigation.emit({\n            type: 'transitionEnd',\n            target: focusedRouteKey,\n          });\n        }\n      });\n    };\n\n    animateToIndex();\n\n    previousRouteKeyRef.current = focusedRouteKey;\n  }, [\n    descriptors,\n    focusedRouteKey,\n    navigation,\n    state.index,\n    state.routes,\n    tabAnims,\n  ]);\n\n  const dimensions = SafeAreaProviderCompat.initialMetrics.frame;\n  const [tabBarHeight, setTabBarHeight] = React.useState(() =>\n    getTabBarHeight({\n      state,\n      descriptors,\n      dimensions,\n      insets: {\n        ...SafeAreaProviderCompat.initialMetrics.insets,\n        ...props.safeAreaInsets,\n      },\n      style: descriptors[state.routes[state.index].key].options.tabBarStyle,\n    })\n  );\n\n  const renderTabBar = () => {\n    return (\n      <SafeAreaInsetsContext.Consumer>\n        {(insets) =>\n          tabBar({\n            state: state,\n            descriptors: descriptors,\n            navigation: navigation,\n            insets: {\n              top: safeAreaInsets?.top ?? insets?.top ?? 0,\n              right: safeAreaInsets?.right ?? insets?.right ?? 0,\n              bottom: safeAreaInsets?.bottom ?? insets?.bottom ?? 0,\n              left: safeAreaInsets?.left ?? insets?.left ?? 0,\n            },\n          })\n        }\n      </SafeAreaInsetsContext.Consumer>\n    );\n  };\n\n  const { routes } = state;\n\n  // If there is no animation, we only have 2 states: visible and invisible\n  const hasTwoStates = !routes.some((route) =>\n    hasAnimation(descriptors[route.key].options)\n  );\n\n  const { tabBarPosition = 'bottom' } = descriptors[focusedRouteKey].options;\n\n  return (\n    <SafeAreaProviderCompat\n      style={{\n        flexDirection:\n          tabBarPosition === 'left' || tabBarPosition === 'right'\n            ? (tabBarPosition === 'left' && direction === 'ltr') ||\n              (tabBarPosition === 'right' && direction === 'rtl')\n              ? 'row-reverse'\n              : 'row'\n            : 'column',\n      }}\n    >\n      {tabBarPosition === 'top' ? (\n        <BottomTabBarHeightCallbackContext.Provider value={setTabBarHeight}>\n          {renderTabBar()}\n        </BottomTabBarHeightCallbackContext.Provider>\n      ) : null}\n      <MaybeScreenContainer\n        enabled={detachInactiveScreens}\n        hasTwoStates={hasTwoStates}\n        style={styles.screens}\n      >\n        {routes.map((route, index) => {\n          const descriptor = descriptors[route.key];\n          const {\n            lazy = true,\n            animation = 'none',\n            sceneStyleInterpolator = NAMED_TRANSITIONS_PRESETS[animation]\n              .sceneStyleInterpolator,\n          } = descriptor.options;\n          const isFocused = state.index === index;\n          const isPreloaded = state.preloadedRouteKeys.includes(route.key);\n\n          if (\n            lazy &&\n            !loaded.includes(route.key) &&\n            !isFocused &&\n            !isPreloaded\n          ) {\n            // Don't render a lazy screen if we've never navigated to it or it wasn't preloaded\n            return null;\n          }\n\n          const {\n            freezeOnBlur,\n            header = ({ layout, options }: BottomTabHeaderProps) => (\n              <Header\n                {...options}\n                layout={layout}\n                title={getHeaderTitle(options, route.name)}\n              />\n            ),\n            headerShown,\n            headerStatusBarHeight,\n            headerTransparent,\n            sceneStyle: customSceneStyle,\n          } = descriptor.options;\n\n          const { sceneStyle } =\n            sceneStyleInterpolator?.({\n              current: {\n                progress: tabAnims[route.key],\n              },\n            }) ?? {};\n\n          const animationEnabled = hasAnimation(descriptor.options);\n          const activityState = isFocused\n            ? STATE_ON_TOP // the screen is on top after the transition\n            : animationEnabled // is animation is not enabled, immediately move to inactive state\n              ? tabAnims[route.key].interpolate({\n                  inputRange: [0, 1 - EPSILON, 1],\n                  outputRange: [\n                    STATE_TRANSITIONING_OR_BELOW_TOP, // screen visible during transition\n                    STATE_TRANSITIONING_OR_BELOW_TOP,\n                    STATE_INACTIVE, // the screen is detached after transition\n                  ],\n                  extrapolate: 'extend',\n                })\n              : STATE_INACTIVE;\n\n          return (\n            <MaybeScreen\n              key={route.key}\n              style={[StyleSheet.absoluteFill, { zIndex: isFocused ? 0 : -1 }]}\n              active={activityState}\n              enabled={detachInactiveScreens}\n              freezeOnBlur={freezeOnBlur}\n              shouldFreeze={activityState === STATE_INACTIVE && !isPreloaded}\n            >\n              <BottomTabBarHeightContext.Provider\n                value={tabBarPosition === 'bottom' ? tabBarHeight : 0}\n              >\n                <Screen\n                  focused={isFocused}\n                  route={descriptor.route}\n                  navigation={descriptor.navigation}\n                  headerShown={headerShown}\n                  headerStatusBarHeight={headerStatusBarHeight}\n                  headerTransparent={headerTransparent}\n                  header={header({\n                    layout: dimensions,\n                    route: descriptor.route,\n                    navigation:\n                      descriptor.navigation as BottomTabNavigationProp<ParamListBase>,\n                    options: descriptor.options,\n                  })}\n                  style={[customSceneStyle, animationEnabled && sceneStyle]}\n                >\n                  {descriptor.render()}\n                </Screen>\n              </BottomTabBarHeightContext.Provider>\n            </MaybeScreen>\n          );\n        })}\n      </MaybeScreenContainer>\n      {tabBarPosition !== 'top' ? (\n        <BottomTabBarHeightCallbackContext.Provider value={setTabBarHeight}>\n          {renderTabBar()}\n        </BottomTabBarHeightCallbackContext.Provider>\n      ) : null}\n    </SafeAreaProviderCompat>\n  );\n}\n\nconst styles = StyleSheet.create({\n  screens: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}