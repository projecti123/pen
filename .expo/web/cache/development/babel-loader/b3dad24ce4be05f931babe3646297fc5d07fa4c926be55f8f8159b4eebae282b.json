{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNormalizedStatePath = exports.getRouteInfoFromState = void 0;\nconst getStateFromPath_forks_1 = require(\"./fork/getStateFromPath-forks\");\nfunction getRouteInfoFromState(getPathFromState, state, baseUrl) {\n  const {\n    path\n  } = getPathFromState(state, false);\n  const qualified = getPathFromState(state, true);\n  return Object.assign({\n    unstable_globalHref: path,\n    pathname: (0, getStateFromPath_forks_1.stripBaseUrl)(path, baseUrl).split('?')['0'],\n    isIndex: isIndexPath(state)\n  }, getNormalizedStatePath(qualified, baseUrl));\n}\nexports.getRouteInfoFromState = getRouteInfoFromState;\nfunction isIndexPath(state) {\n  const route = state.routes[state.index ?? state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n  if (route.params && 'screen' in route.params) {\n    return route.params.screen === 'index';\n  }\n  if (route.name.match(/.+\\/index$/)) return true;\n  return false;\n}\nfunction getNormalizedStatePath({\n  path: statePath,\n  params\n}, baseUrl) {\n  const [pathname] = statePath.split('?');\n  return {\n    segments: (0, getStateFromPath_forks_1.stripBaseUrl)(pathname, baseUrl).split('/').filter(Boolean).map(decodeURIComponent),\n    params: decodeParams(params)\n  };\n}\nexports.getNormalizedStatePath = getNormalizedStatePath;\nfunction decodeParams(params) {\n  const parsed = {};\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (key === 'params' && typeof value === 'object') {\n        parsed[key] = decodeParams(value);\n      } else if (Array.isArray(value)) {\n        parsed[key] = value.map(v => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n  return parsed;\n}","map":{"version":3,"names":["getStateFromPath_forks_1","require","getRouteInfoFromState","getPathFromState","state","baseUrl","path","qualified","Object","assign","unstable_globalHref","pathname","stripBaseUrl","split","isIndex","isIndexPath","getNormalizedStatePath","exports","route","routes","index","length","params","screen","name","match","statePath","segments","filter","Boolean","map","decodeURIComponent","decodeParams","parsed","key","value","entries","Array","isArray","v"],"sources":["/Users/tanishakumari/StudySphere/node_modules/expo-router/src/LocationProvider.tsx"],"sourcesContent":["import { type State } from './fork/getPathFromState';\nimport { stripBaseUrl } from './fork/getStateFromPath-forks';\n\ntype SearchParams = Record<string, string | string[]>;\n\nexport type UrlObject = {\n  unstable_globalHref: string;\n  pathname: string;\n  readonly params: SearchParams;\n  segments: string[];\n  isIndex: boolean;\n};\n\nexport function getRouteInfoFromState(\n  getPathFromState: (state: State, asPath: boolean) => { path: string; params: any },\n  state: State,\n  baseUrl?: string\n): UrlObject {\n  const { path } = getPathFromState(state, false);\n  const qualified = getPathFromState(state, true);\n\n  return {\n    // TODO: This may have a predefined origin attached in the future.\n    unstable_globalHref: path,\n    pathname: stripBaseUrl(path, baseUrl).split('?')['0'],\n    isIndex: isIndexPath(state),\n    ...getNormalizedStatePath(qualified, baseUrl),\n  };\n}\n\nfunction isIndexPath(state: State) {\n  const route = state.routes[state.index ?? state.routes.length - 1];\n  if (route.state) {\n    return isIndexPath(route.state);\n  }\n\n  // Index routes on the same level as a layout do not have `index` in their name\n  if (route.params && 'screen' in route.params) {\n    return route.params.screen === 'index';\n  }\n\n  // The `params` key will not exist if there are no params\n  // So we need to do a positive lookahead to check if the route ends with /index\n  // Nested routes that are hoisted will have a name ending with /index\n  // e.g name could be /user/[id]/index\n  if (route.name.match(/.+\\/index$/)) return true;\n\n  // The state will either have params (because there are multiple _layout) or it will be hoisted with a name\n  // If we don't match the above cases, then it's not an index route\n\n  return false;\n}\n\n// TODO: Split up getPathFromState to return all this info at once.\nexport function getNormalizedStatePath(\n  {\n    path: statePath,\n    params,\n  }: {\n    path: string;\n    params: any;\n  },\n  baseUrl?: string\n): Pick<UrlObject, 'segments' | 'params'> {\n  const [pathname] = statePath.split('?');\n  return {\n    // Strip empty path at the start\n    segments: stripBaseUrl(pathname, baseUrl).split('/').filter(Boolean).map(decodeURIComponent),\n    // TODO: This is not efficient, we should generate based on the state instead\n    // of converting to string then back to object\n    params: decodeParams(params),\n  };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (key === 'params' && typeof value === 'object') {\n        parsed[key] = decodeParams(value);\n      } else if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n"],"mappings":";;;;;;AACA,MAAAA,wBAAA,GAAAC,OAAA;AAYA,SAAgBC,qBAAqBA,CACnCC,gBAAkF,EAClFC,KAAY,EACZC,OAAgB;EAEhB,MAAM;IAAEC;EAAI,CAAE,GAAGH,gBAAgB,CAACC,KAAK,EAAE,KAAK,CAAC;EAC/C,MAAMG,SAAS,GAAGJ,gBAAgB,CAACC,KAAK,EAAE,IAAI,CAAC;EAE/C,OAAAI,MAAA,CAAAC,MAAA;IAEEC,mBAAmB,EAAEJ,IAAI;IACzBK,QAAQ,EAAE,IAAAX,wBAAA,CAAAY,YAAY,EAACN,IAAI,EAAED,OAAO,CAAC,CAACQ,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACrDC,OAAO,EAAEC,WAAW,CAACX,KAAK;EAAC,GACxBY,sBAAsB,CAACT,SAAS,EAAEF,OAAO,CAAC;AAEjD;AAfAY,OAAA,CAAAf,qBAAA,GAAAA,qBAAA;AAiBA,SAASa,WAAWA,CAACX,KAAY;EAC/B,MAAMc,KAAK,GAAGd,KAAK,CAACe,MAAM,CAACf,KAAK,CAACgB,KAAK,IAAIhB,KAAK,CAACe,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC;EAClE,IAAIH,KAAK,CAACd,KAAK,EAAE;IACf,OAAOW,WAAW,CAACG,KAAK,CAACd,KAAK,CAAC;;EAIjC,IAAIc,KAAK,CAACI,MAAM,IAAI,QAAQ,IAAIJ,KAAK,CAACI,MAAM,EAAE;IAC5C,OAAOJ,KAAK,CAACI,MAAM,CAACC,MAAM,KAAK,OAAO;;EAOxC,IAAIL,KAAK,CAACM,IAAI,CAACC,KAAK,CAAC,YAAY,CAAC,EAAE,OAAO,IAAI;EAK/C,OAAO,KAAK;AACd;AAGA,SAAgBT,sBAAsBA,CACpC;EACEV,IAAI,EAAEoB,SAAS;EACfJ;AAAM,CAIP,EACDjB,OAAgB;EAEhB,MAAM,CAACM,QAAQ,CAAC,GAAGe,SAAS,CAACb,KAAK,CAAC,GAAG,CAAC;EACvC,OAAO;IAELc,QAAQ,EAAE,IAAA3B,wBAAA,CAAAY,YAAY,EAACD,QAAQ,EAAEN,OAAO,CAAC,CAACQ,KAAK,CAAC,GAAG,CAAC,CAACe,MAAM,CAACC,OAAO,CAAC,CAACC,GAAG,CAACC,kBAAkB,CAAC;IAG5FT,MAAM,EAAEU,YAAY,CAACV,MAAM;GAC5B;AACH;AAlBAL,OAAA,CAAAD,sBAAA,GAAAA,sBAAA;AAoBA,SAASgB,YAAYA,CAACV,MAA8B;EAClD,MAAMW,MAAM,GAAwB,EAAE;EAEtC,KAAK,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,IAAI3B,MAAM,CAAC4B,OAAO,CAACd,MAAM,CAAC,EAAE;IACjD,IAAI;MACF,IAAIY,GAAG,KAAK,QAAQ,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;QACjDF,MAAM,CAACC,GAAG,CAAC,GAAGF,YAAY,CAACG,KAAK,CAAC;OAClC,MAAM,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;QAC/BF,MAAM,CAACC,GAAG,CAAC,GAAGC,KAAK,CAACL,GAAG,CAAES,CAAC,IAAKR,kBAAkB,CAACQ,CAAC,CAAC,CAAC;OACtD,MAAM;QACLN,MAAM,CAACC,GAAG,CAAC,GAAGH,kBAAkB,CAACI,KAAK,CAAC;;KAE1C,CAAC,MAAM;MACNF,MAAM,CAACC,GAAG,CAAC,GAAGC,KAAK;;;EAIvB,OAAOF,MAAM;AACf","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"script","externalDependencies":[]}